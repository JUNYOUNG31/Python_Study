# 사칙연산

# 사칙연산으로 구성되어 있는 식은 이진 트리로 표현할 수 있다. 아래는 식 “(9/(6-4))*3”을 이진 트리로 표현한 것이다.
# 임의의 정점에 연산자가 있으면 해당 연산자의 왼쪽 서브 트리의 결과와 오른쪽 서브 트리의
# 결과를 사용해서 해당 연산자를 적용한다.
# 사칙연산 “+, -, *, /”와 양의 정수로만 구성된 임의의 이진트리가 주어질 때,
# 이를 계산한 결과를 출력하는 프로그램을 작성하라.
# 단, 중간 과정에서의 연산은 실수 연산으로 하되, 최종 결과값이 정수로 떨어지지 않으면 정수부만 출력한다.
# 위의 예에서는 최종 결과값이 13.5이므로 13을 출력하면 된다.

# 각 테스트 케이스의 첫 줄에는 각 케이스의 트리가 갖는 정점의 총 수 N(1≤N≤1000)이 주어진다.
# 그 다음 N줄에 걸쳐 각각의 정점 정보가 주어진다.
# 정점이 단순한 수이면 정점번호와 해당 양의 정수가 주어지고, 정점이 연산자이면 정점번호, 연산자,
# 해당 정점의 왼쪽 자식, 오른쪽 자식의 정점번호가 차례대로 주어진다.
# 정점번호는 1부터 N까지의 정수로 구분된다. 입력에서 정점 번호를 매기는 특별한 규칙은 없으나,
# 루트 정점의 번호는 반드시 1이다.
# 입력에서 이웃한 수나 연산자는 모두 공백으로 구분된다.
# 위의 예시에서, 숫자 4가 7번 정점에 해당하면 “7 4”으로 주어지고, 연산자 ‘/’가 2번 정점에 해당하면
# 두 자식이 각각 숫자 9인 4번 정점과 연산자 ‘-’인 5번 정점이므로 “2 / 4 5”로 주어진다.
# 총 10개의 테스트 케이스가 주어진다.
def postorder(V):                   # 후위순회
    if V >= N:
        return
    if tree[V][2]:                  # 왼쪽 자식
        postorder(tree[V][2])
    if tree[V][3]:                  # 오른쪽 자식
        postorder(tree[V][3])

    if tree[V][1] == '+':           # 사칙연산
        tree[V][1] = tree[tree[V][2]][1] + tree[tree[V][3]][1]
    elif tree[V][1] == '-':
        tree[V][1] = tree[tree[V][2]][1] - tree[tree[V][3]][1]
    elif tree[V][1] == '*':
        tree[V][1] = tree[tree[V][2]][1] * tree[tree[V][3]][1]
    elif tree[V][1] == '/':
        tree[V][1] = tree[tree[V][2]][1] / tree[tree[V][3]][1]


for tc in range(1, 11):                             # case 반복
    N = int(input())                                # 수입력
    tree = [[0, 0, 0, 0] for _ in range(N+1)]       # 트리 생성 #노드 연산자 왼쪽노드 오른쪽노드
    for i in range(N):                              # 노드반복
        node = list(input().split())                # 노드 입력
        if len(node) == 4:                          # 길이가 4면 연산자가 있는거
            tree[int(node[0])][1] = node[1]         # 연산자
            tree[int(node[0])][2] = int(node[2])    # 왼쪽 자식
            tree[int(node[0])][3] = int(node[3])    # 오른쪽 자식
        else:                                       # 없으면 숫자만 입력
            tree[int(node[0])][1] = int(node[1])
    postorder(1)                                    # 후위순회
    print("#{} {}".format(tc, int(tree[1][1])))     # 첫번째 값 출력