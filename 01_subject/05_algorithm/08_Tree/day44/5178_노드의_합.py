# 노드의 합

# 완전 이진 트리의 리프 노드에 1000이하의 자연수가 저장되어 있고, 리프 노드를 제외한 노드에는 자식 노드에
# 저장된 값의 합이 들어있다고 한다.
# 다음은 리프 노드에 저장된 1, 2, 3이 주어졌을 때, 나머지 노드에 자식 노드의 합을 저장한 예이다.
# N개의 노드를 갖는 완전 이진 트리의 노드 번호는 루트가 1번이 되며, 같은 단계에서는 왼쪽에서 오른쪽으로 증가,
# 단계가 꽉 차면 다음단계의 왼쪽부터 시작된다.
# 완전 이진 트리의 특성상 1번부터 N번까지 빠지는 노드 번호는 없다.
# 리프 노드의 번호와 저장된 값이 주어지면 나머지 노드에 자식 노드 값의 합을 저장한 다음,
# 지정한 노드 번호에 저장된 값을 출력하는 프로그램을 작성 하시오.

# 첫 줄에 테스트케이스의 수 T가 주어진다. 1<=T<=50
# 다음 줄부터 테스트 케이스의 별로 노드의 개수 N과 리프 노드의 개수 M, 값을 출력할 노드 번호 L이 주어지고,
# 다음 줄부터 M개의 줄에 걸쳐 리프 노드 번호와 1000이하의 자연수가 주어진다.
def dfs(i):                                         # 깊이 탐색
    if i > N:                                       # 인덱스 넘어가면 0 으로 리턴
        return 0
    if tree[i]:                                     # 값이 있으면
        return tree[i]
    left = i*2                                      # 왼쪽 자식 노드
    right = i*2 + 1                                 # 오른쪽 자식 노드
    tree[i] = dfs(left) + dfs(right)                # 두 개의 합
    return tree[i]


T = int(input())                                     # case 수
for tc in range(1, T + 1):                           # case 반복
    N, M, L = list(map(int, input().split()))        # 노드수, 리프노드 수,  출력할 노드 번호
    tree = [0 for _ in range(N + 2)]                 # 트리 생성
    for i in range(M):                               # 노드 입력
        A, B = list(map(int, input().split()))
        tree[A] = B                                  # 추가
    # print(tree)
    print("#{} {}".format(tc, dfs(L)))