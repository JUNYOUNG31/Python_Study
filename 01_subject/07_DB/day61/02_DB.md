# day 61

## DB

## Model Relationship 1



## intro: 병원 진료 기록 시스템

###  1:N의 한계

```
* 의사 2명과 환자 2명 생성
* doctor1 - patient1
* doctor2 - patient2
* 한명의 환자가 2명의 의사에게 진료를 받고자함
* 하나의 외래 키에 2개의 의사 데이터를 넣을 수 없음

>> 새로운 객체를 생성해야한다
```

```python
# hospitals/models.py
from django.db import models

class Doctor(models.Model):
    name = models.TextField()
    def __str__(self):
        return f'{self.pk}번 의사 {self.name}'

class Patient(models.Model):
    name = models.TextField()
    doctor = models.ForeignKey(Doctor, on_delete=models.CASCADE)
    def __str__(self):
        return f'{self.pk}번 환자 {self.name}'
```



### 중개 모델(혹은 중개 테이블, Associative Table)작성

```
* doctor - reservation - patient
```

```python
# hospitals/models.py
from django.db import models

class Doctor(models.Model):
    name = models.TextField()
    def __str__(self):
        return f'{self.pk}번 의사 {self.name}'

class Patient(models.Model):
    name = models.TextField()    
    # 외래키 삭제
    def __str__(self):
        return f'{self.pk}번 환자 {self.name}'
    
# 중개모델 작성
class Reservation(models.Model):
    doctor = models.ForeignKey(Doctor, on_delete=models.CASCADE)
    patient = models.ForeignKey(Patient, on_delete=models.CASCADE)
    def __str__(self):
        return f'{self.doctor_id}번 의사의 {self.patient_id}번 환자'
```



###  ManyToManyField

```
* 다대다(M:N, many-to-many) 관계 설정 시 사용하는 모델 필드
* 하나의 필수 위치인자(M:N 관계로 설정할 모델 클래스)가 필요
* 필드 위치는 Doctor or Patient 모두 작성 가능
```

````python
# hospitals/models.py
from django.db import models

class Doctor(models.Model):
    name = models.TextField()
    def __str__(self):
        return f'{self.pk}번 의사 {self.name}'

class Patient(models.Model):
    doctors = models.ManyToManyField(Doctor)
    name = models.TextField()
    def __str__(self):
        return f'{self.pk}번 환자 {self.name}'
````



### related_name

```
* target model(관계 필드를 가지지 않는 모델)이 source model(관계 필드를 가진 모델)을 참조할 때 사용할
  manager의 이름을 설정
* 즉, 역참조 시 사용하는 manager의 이름을 설정
* ForeignKey의 related_name과 동일
* 설정 후 기존의 _set 은 사용할 수 없다
```

```python
class Patient(models.Model):
    name = models.TextField()
    doctors = models.ManyToManyField(Doctor, related_name='patients')
```



## ManyToManyField

### 개념과 특징

```
* 다대다(M:N, many-to-many) 관계 설정 시 사용하는 모델 필드
* 하나의 필수 위치인자(M:N 관계로 설정할 모델 클래스)가 필요
* 모델 필드의 RelatedManager를 사용하여 관련 개체를 추가, 제거 또는 만들 수 있다.
  * add(), remove()
```



### Arguments(인수)

```
1.related_name
* target model(관계 필드를 가지지 않는 모델)이 source model(관계 필드를 가진 모델)을 참조할 때 사용할
  manager의 이름을 설정
* ForeignKey의 related_name과 동일

2.through
* 중개 테이블을 직접 작성하는 경우, through 옵션을 사용하여 중개 테이블을 나타내는 Django 모델을 지정
* 일반적으로 중개 테이블에 추가 데이터를 사용하는 다대다 관계와 연결하려는 경우에 주로 사용

3.symmetrical
* ManyToManyField가 동일한 모델(on self)을 가리키는 정의에서만 사용
* symmetrical=True(기본값)일 경우 django는 person_set매니저를 추가하지 않음
* source 모델의 인스턴스가 target 모델의 인스턴스를 참조하면, target 모델 인스턴스도 
  source 모델 인스턴스를 자동으로 참조하도록 함
* 즉, 인스타그램에서 내가 상대방을 팔로우 하면 상대방도 나를 자동으로 팔로우 한다
* 대칭을 원하지 않으면 False로 설정
```



### Related Manager

```
* 1:N 또는 M:N 관련 컨텍스트에서 사용되는 매니저
* 같은 이름의 메서드여도 각 관계(1:N,M:N)에 따라 다르게 사용 및 동작
  -1:N에서는 target 모델 인스턴스만 사용 가능
  -M:N에서는 관련된 두 객체에서 모두 사용 가능

* add()
  지정된 객체를 관련 객체 집합에 추가
  이미 존재하는 관계에 사용하면 관계가 복제되지 않음
  모델 인스턴스, pk 을 인자로 허용
  
* remove()
  관련 객체 집합에서 지정된 모델 객체를 제거
  내부적으로 QuerySet.delete()를 사용하여 관계가 삭제됨
  모델 인스턴스, pk 을 인자로 허용
```



### through

```python
class Doctor(models.Model):
    name = models.TextField()
    def __str__(self):
        return f'{self.pk}번 의사 {self.name}'

class Patient(models.Model):
    doctors = models.ManyToManyField(Doctor, through='Reservation')
    name = models.TextField()
    def __str__(self):
        return f'{self.pk}번 환자 {self.name}'

class Reservation(models.Model):
    doctor = models.ForeignKey(Doctor, on_delete=models.CASCADE)
    patient = models.ForeignKey(Patient, on_delete=models.CASCADE)
    symptom = models.TextField()
    reserved_at = models.DateTimeField(auto_now_add=True)
    def __str__(self):
        return f'{self.doctor.pk}번 의사의 {self.patient.pk}번 환자'
```

